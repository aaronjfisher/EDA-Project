yes[i,1:n]<-y
pi<-pvals[i]
bini<-min(which(pi<pbreaks))
if(bini==pbins[i]) tryagain<-F
}
#plot(x,y,main=n)
#readline(prompt='go')
}
################################################
#Fix those that now get an extra outlier
#add it one sd above the max x and max y, or w/e is appropriate for the upper corner that works
#if it's not sig, add the outlier close to above the mean.
for(i in which(pres=='outlier')){
tryAgain<-TRUE
itc<-0
while(tryAgain){
n<-nes[i]
sig.i<-pvals[i]<.05
#grab the middle point from x and y
mx<-rep(mean(x),n)
my<-rep(mean(y),n)
x<-xes[i,1:n]
y<-yes[i,1:n]
distvec<-sqrt((mx-x)^2+(my-y)^2)
switch<-which(distvec==min(distvec))
#NOTE IT PREV VERSIONS THIS NICE DEALY LET US RANDOMLY PUT THE OUTLIER IN W/E CORNER WE WANTED
#Put it in an UPPER CORNER
if(tvals[i]<1 & sig.i) { #slope going down
x[switch]<-min(x)-sd(x)
y[switch]<-max(y)+sd(y)
}
if(tvals[i]>1 & sig.i) {
x[switch]<-max(x)+sd(x)
y[switch]<-max(y)+sd(y)
}
if(!sig.i){
#leave X where it is now
y[switch]<-max(y)+sd(y)*sqrt(2)
}
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
itc<-itc+1
if(sig.i&pvals[i]<.04) tryAgain=FALSE
if(!sig.i&pvals[i]>.06) tryAgain=FALSE
}
xes[i,1:n]<-x
yes[i,1:n]<-y
}
itc
source('~/.active-rstudio-document', echo=TRUE)
#COURSERA STUFF
#Here we're using 7 questions
#Each with 2 versions, one significant one not
#Questions are: Small sample (35), medium sample (100) (reference),
#large sample (200), axis scale, labels, outlier, bestfit
set.seed(234032)
#Intro question:
setwd("/Users/aaronfisher/Documents/JH/EDA Versions/Sourcetree EDA Git Repo/Coursera")
nreps<-14
pbreaks<-c(.01,.03,.07,.5,1)
pbins<-rep(c(2,4),times=7)
nes<-c(35,35,100,100,200,200,rep(100,times=8))
yes<-matrix(nrow=nreps,ncol=max(nes))
xes<-matrix(nrow=nreps,ncol=max(nes))
pvals<-1 #initialize variables
tvals<-1
pres<-c(rep('plain',length=6),rep(c('bestFit','axesScale','axesLabel','outlier'),each=2))
#dropping Lowess here
#First generate baseline data
#then add presentation data (same data + presentaion vector)
#then change data for when the twist is adding an outlier
for(i in 1:nreps){
tryagain<-T
#	if(i %in% c(1:100*nreps/100)) print(i)
while(tryagain){ #to ENSURE that we get a good mix of p-value ranges
#get t close to what we want
t<-qnorm(pbreaks[pbins[i]],mean=0,sd=1,lower.tail=F)
if(abs(t)>5)t<-0 #guards against when the bin is 1, and quantile has infinite size
n<-nes[i]
x<-rnorm(n)
e<-rnorm(n)
bhat<-t*sd(e)/(sqrt(n)*sd(x))
if(pbins[i]>=5 & sample(c(2,2,1),1)==2) bhat<-0 #sometimes generate it actually from a null
y<-x*bhat*sample(c(-1,1),1)+e
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
xes[i,1:n]<-x
yes[i,1:n]<-y
pi<-pvals[i]
bini<-min(which(pi<pbreaks))
if(bini==pbins[i]) tryagain<-F
}
#plot(x,y,main=n)
#readline(prompt='go')
}
################################################
#Fix those that now get an extra outlier
#add it one sd above the max x and max y, or w/e is appropriate for the upper corner that works
#if it's not sig, add the outlier close to above the mean.
for(i in which(pres=='outlier')){
tryAgain<-TRUE
itc<-0
while(tryAgain){
n<-nes[i]
sig.i<-pvals[i]<.05
#grab the middle point from x and y
mx<-rep(mean(x),n)
my<-rep(mean(y),n)
x<-xes[i,1:n]
y<-yes[i,1:n]
distvec<-sqrt((mx-x)^2+(my-y)^2)
switch<-which(distvec==min(distvec))
#NOTE IT PREV VERSIONS THIS NICE DEALY LET US RANDOMLY PUT THE OUTLIER IN W/E CORNER WE WANTED
#Put it in an UPPER CORNER
if(tvals[i]<1 & sig.i) { #slope going down
x[switch]<-min(x)-sd(x)
y[switch]<-max(y)+sd(y)
}
if(tvals[i]>1 & sig.i) {
x[switch]<-max(x)+sd(x)
y[switch]<-max(y)+sd(y)
}
if(!sig.i){
#leave X where it is now
y[switch]<-max(y)+sd(y)*sqrt(2)
}
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
itc<-itc+1
print(itc)
if(sig.i&pvals[i]<.04) tryAgain=FALSE
if(!sig.i&pvals[i]>.06) tryAgain=FALSE
}
xes[i,1:n]<-x
yes[i,1:n]<-y
}
plot(xes[14,],yes[14,])
for(i in which(pres=='outlier')){
tryAgain<-TRUE
while(tryAgain){
n<-nes[i]
sig.i<-pvals[i]<.05
#grab the middle point from x and y
mx<-rep(mean(x),n)
my<-rep(mean(y),n)
x<-xes[i,1:n]
y<-yes[i,1:n]
distvec<-sqrt((mx-x)^2+(my-y)^2)
switch<-which(distvec==min(distvec))
#NOTE IT PREV VERSIONS THIS NICE DEALY LET US RANDOMLY PUT THE OUTLIER IN W/E CORNER WE WANTED
#Put it in an UPPER CORNER
if(tvals[i]<1 & sig.i) { #slope going down
x[switch]<-min(x)-sd(x)
y[switch]<-max(y)+sd(y)
}
if(tvals[i]>1 & sig.i) {
x[switch]<-max(x)+sd(x)
y[switch]<-max(y)+sd(y)
}
if(!sig.i){
#leave X where it is now
y[switch]<-max(y)+sd(y)*sqrt(2)
}
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
if(sig.i&pvals[i]<.04) tryAgain=FALSE
if(!sig.i&pvals[i]>.06) tryAgain=FALSE
}
xes[i,1:n]<-x
yes[i,1:n]<-y
}
set.seed(234032)
#Intro question:
setwd("/Users/aaronfisher/Documents/JH/EDA Versions/Sourcetree EDA Git Repo/Coursera")
nreps<-14
pbreaks<-c(.01,.03,.07,.5,1)
pbins<-rep(c(2,4),times=7)
nes<-c(35,35,100,100,200,200,rep(100,times=8))
yes<-matrix(nrow=nreps,ncol=max(nes))
xes<-matrix(nrow=nreps,ncol=max(nes))
pvals<-1 #initialize variables
tvals<-1
pres<-c(rep('plain',length=6),rep(c('bestFit','axesScale','axesLabel','outlier'),each=2))
#dropping Lowess here
#First generate baseline data
#then add presentation data (same data + presentaion vector)
#then change data for when the twist is adding an outlier
for(i in 1:nreps){
tryagain<-T
#	if(i %in% c(1:100*nreps/100)) print(i)
while(tryagain){ #to ENSURE that we get a good mix of p-value ranges
#get t close to what we want
t<-qnorm(pbreaks[pbins[i]],mean=0,sd=1,lower.tail=F)
if(abs(t)>5)t<-0 #guards against when the bin is 1, and quantile has infinite size
n<-nes[i]
x<-rnorm(n)
e<-rnorm(n)
bhat<-t*sd(e)/(sqrt(n)*sd(x))
if(pbins[i]>=5 & sample(c(2,2,1),1)==2) bhat<-0 #sometimes generate it actually from a null
y<-x*bhat*sample(c(-1,1),1)+e
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
xes[i,1:n]<-x
yes[i,1:n]<-y
pi<-pvals[i]
bini<-min(which(pi<pbreaks))
if(bini==pbins[i]) tryagain<-F
}
#plot(x,y,main=n)
#readline(prompt='go')
}
################################################
#Fix those that now get an extra outlier
#add it one sd above the max x and max y, or w/e is appropriate for the upper corner that works
#if it's not sig, add the outlier close to above the mean.
for(i in which(pres=='outlier')){
tryAgain<-TRUE
while(tryAgain){
n<-nes[i]
sig.i<-pvals[i]<.05
#grab the middle point from x and y
mx<-rep(mean(x),n)
my<-rep(mean(y),n)
x<-xes[i,1:n]
y<-yes[i,1:n]
distvec<-sqrt((mx-x)^2+(my-y)^2)
switch<-which(distvec==min(distvec))
#NOTE IT PREV VERSIONS THIS NICE DEALY LET US RANDOMLY PUT THE OUTLIER IN W/E CORNER WE WANTED
#Put it in an UPPER CORNER
if(tvals[i]<1 & sig.i) { #slope going down
x[switch]<-min(x)-sd(x)
y[switch]<-max(y)+sd(y)
}
if(tvals[i]>1 & sig.i) {
x[switch]<-max(x)+sd(x)
y[switch]<-max(y)+sd(y)
}
if(!sig.i){
#leave X where it is now
y[switch]<-max(y)+sd(y)*sqrt(2)
}
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
if(sig.i&pvals[i]<.04) tryAgain=FALSE
if(!sig.i&pvals[i]>.06) tryAgain=FALSE
}
xes[i,1:n]<-x
yes[i,1:n]<-y
}
pvals
save(list=c('xes','yes','nreps','pbins','pvals','tvals','nes','pres'),file='data_for_1plots_coursera2.RData')
#load('data_for_1plots_coursera2.RData')
load('data_for_1plots_coursera2.RData')
round(pvals[i],digits=3)
nreps
#Note, this works b/c there's no replicates
for(i in 1:nreps){
n<-nes[i]
x<-xes[i,1:n]
y<-yes[i,1:n]
pval<-pvals[i]
tval<-tvals[i]
m<-lm(y~x)
style<-pres[i]
t2<-'Data'
if(style=='lowess') t2<-'with Lowess Line'
if(style=='bestFit') t2<-'with OLS Best Fit Line'
title<-paste('Sample ',t2,sep='')
xl<-paste("Cranial Electrode",floor(runif(1,11,44)),"(Standardized)")
yl<-paste("Cranial Electrode",floor(runif(1,53,97)),"(Standardized)")
drx<-diff(range(x))
dry<-diff(range(y))
png(paste("images/coursera2_num",i,'pres:',pres[i],'pval',round(pvals[i],digits=3),".png"), width = 400, height = 400)
par(mfrow=c(1,1))
plot(x,y,xlab='X',ylab='Y',main=title)
if(style=='lowess') lines(lowess(x,y))
if(style=='bestFit') abline(m$coef)
if(style=='axesScale')plot(x,y,xlab='X',ylab='Y',main=title,xlim=c(min(x)-1.5*sd(x),max(x)+1.5*sd(x)),ylim=c(min(y)-1.5*sd(y),max(y)+1.5*sd(y)))
if(style=='outlier')plot(x,y,xlab='X',ylab='Y',main=title,xlim=c(min(x)-.1*drx,max(x)+.1*drx),ylim=c(min(y)-.1*dry,max(y)+.1*dry) )
if(style=='axesLabel') plot(x,y,xlab=xl,ylab=yl,main=title)
dev.off()
}
ote, this works b/c there's no replicates
for(i in 1:nreps){
n<-nes[i]
x<-xes[i,1:n]
y<-yes[i,1:n]
pval<-pvals[i]
tval<-tvals[i]
m<-lm(y~x)
style<-pres[i]
t2<-'Data'
if(style=='lowess') t2<-'with Lowess Line'
if(style=='bestFit') t2<-'with OLS Best Fit Line'
title<-paste('Sample ',t2,sep='')
xl<-paste("Cranial Electrode",floor(runif(1,11,44)),"(Standardized)")
yl<-paste("Cranial Electrode",floor(runif(1,53,97)),"(Standardized)")
drx<-diff(range(x))
dry<-diff(range(y))
png(paste("images/coursera2_num",i,'pres:',pres[i],'pval',round(pvals[i],digits=3),".png"), width = 400, height = 400)
par(mfrow=c(1,1))
plot(x,y,xlab='X',ylab='Y',main=title)
if(style=='lowess') lines(lowess(x,y))
if(style=='bestFit') abline(m$coef)
if(style=='axesScale')plot(x,y,xlab='X',ylab='Y',main=title,xlim=c(min(x)-1.5*sd(x),max(x)+1.5*sd(x)),ylim=c(min(y)-1.5*sd(y),max(y)+1.5*sd(y)))
if(style=='outlier')plot(x,y,xlab='X',ylab='Y',main=title,xlim=c(min(x)-.1*drx,max(x)+.1*drx),ylim=c(min(y)-.1*dry,max(y)+.1*dry) )
if(style=='axesLabel') plot(x,y,xlab=xl,ylab=yl,main=title)
dev.off()
}
png(paste0("images/coursera2_num:",i,'_pres:',pres[i],'_pval:',round(pvals[i],digits=3),".png")
paste0("images/coursera2_num:",i,'_pres:',pres[i],'_pval:',round(pvals[i],digits=3),".png")
#Note, this works b/c there's no replicates
for(i in 1:nreps){
n<-nes[i]
x<-xes[i,1:n]
y<-yes[i,1:n]
pval<-pvals[i]
tval<-tvals[i]
m<-lm(y~x)
style<-pres[i]
t2<-'Data'
if(style=='lowess') t2<-'with Lowess Line'
if(style=='bestFit') t2<-'with OLS Best Fit Line'
title<-paste('Sample ',t2,sep='')
xl<-paste("Cranial Electrode",floor(runif(1,11,44)),"(Standardized)")
yl<-paste("Cranial Electrode",floor(runif(1,53,97)),"(Standardized)")
drx<-diff(range(x))
dry<-diff(range(y))
png(paste0("images/coursera2_num-",i,'_pres-',pres[i],'_pval-',round(pvals[i],digits=3),".png"), width = 400, height = 400)
par(mfrow=c(1,1))
plot(x,y,xlab='X',ylab='Y',main=title)
if(style=='lowess') lines(lowess(x,y))
if(style=='bestFit') abline(m$coef)
if(style=='axesScale')plot(x,y,xlab='X',ylab='Y',main=title,xlim=c(min(x)-1.5*sd(x),max(x)+1.5*sd(x)),ylim=c(min(y)-1.5*sd(y),max(y)+1.5*sd(y)))
if(style=='outlier')plot(x,y,xlab='X',ylab='Y',main=title,xlim=c(min(x)-.1*drx,max(x)+.1*drx),ylim=c(min(y)-.1*dry,max(y)+.1*dry) )
if(style=='axesLabel') plot(x,y,xlab=xl,ylab=yl,main=title)
dev.off()
}
head(xes)
dim(xes)
image(xes)
image(t(xes))
image(t(xes[1:nrow(xes),]))
image(t(xes[1:nrow(xes),]))
image(t(xes[nrow(xes):1,]))
image0
imaget<-image(t(xes[nrow(xes):1,]))
imageo<-image(t(xes[nrow(xes):1,]))
image0<-image(t(xes[nrow(xes):1,]))
image0(xes)
image0<-image(t(xes[nrow(xes):1,]))
image0
image0(xes)
image0<-function(x) image(t(x[nrow(x):1,]))
image0(xes)
rm(list=ls())
rm(list=ls())
#load('C:/Users/Aaron/Documents/AaronsFunctions.RData')
disp<-function(){
if(.Platform$OS.type=="windows") windows()
else quartz()
}
ci<-function(model,Bnumber){
summary(model)$coef[Bnumber,1]+c(-1,1)*1.96*summary(model)$coef[Bnumber,2]
}
inrange<-function(x,l=0,u=1,strict=F){
inval<-F
if(x<=u & x>=l) inval<-T
if(x %in% c(u,l) & strict) inval<-F
return(inval)
}
library(colorspace)
image0<-function(x) image(t(x[nrow(x):1,]))
pal <- function(col, border = "light gray", ...)
#Copy pasted from HCL-Based Color Palettes in R
#http://cran.r-project.org/web/packages/colorspace/vignettes/hcl-colors.pdf
{
n <- length(col)
plot(0, 0, type="n", xlim = c(0, 1), ylim = c(0, 1),
axes = FALSE, xlab = "", ylab = "", ...)
rect(0:(n-1)/n, 0, 1:n/n, 1, col = col, border = border)
}
#rainbow_hcl(10)
#pal(rainbow_hcl(50,c=100,l=80))
#pal(sequential_hcl(50))
c.r.hcl<-function(x,n=1000, ...){ #cut rainbow_hcl
xCut<-cut(x,breaks=n)
colors<-rainbow_hcl(n=n, ...)
out<-colors[xCut]
return(out)
}
c.s.hcl<-function(x,n=1000, ...){ #cut rainbow_hcl
xCut<-cut(x,breaks=n)
colors<-sequential_hcl(n=n, ...)[n:1]#reverse the order
out<-colors[xCut]
return(out)
}
c.d.hcl<-function(x,n=1000, ...){ #cut rainbow_hcl
xCut<-cut(x,breaks=n)
colors<-diverge_hcl(n=n, ...)
out<-colors[xCut]
return(out)
}
splitpun<-function(words.in){ #splits text up by most punctuation terms, and then by spaces.
words.pre1<-unlist(strsplit(words.in,split=c('\\.')))
words.pre2<-unlist(strsplit(words.pre1,split=c('\\,')))
words.pre3<-unlist(strsplit(words.pre2,split=c('!')))
words.pre4<-unlist(strsplit(words.pre3,split=c('\\?')))
words.pre5<-unlist(strsplit(words.pre4,split=c('\\"')))
words.pre6<-unlist(strsplit(words.pre5,split=c(':')))
words.pre7<-unlist(strsplit(words.pre6,split=c(';')))
words.out1<-unlist(strsplit(words.pre7,split=' '))
words.out2<-words.out1[nchar(words.out1)>0]
return(words.out2)
}
setwd('/Users/aaronfisher/Documents')
save.image(file='AaronsFunctions.RData')
rm(list=ls())
set.seed(234032)
#Intro question:
setwd("/Users/aaronfisher/Documents/JH/EDA Versions/Sourcetree EDA Git Repo/Coursera")
nreps<-14
pbreaks<-c(.01,.03,.07,.5,1)
pbins<-rep(c(2,4),times=7)
nes<-c(35,35,100,100,200,200,rep(100,times=8))
yes<-matrix(nrow=nreps,ncol=max(nes))
xes<-matrix(nrow=nreps,ncol=max(nes))
pvals<-1 #initialize variables
tvals<-1
pres<-c(rep('plain',length=6),rep(c('bestFit','axesScale','axesLabel','outlier'),each=2))
#dropping Lowess here
#First generate baseline data
#then add presentation data (same data + presentaion vector)
#then change data for when the twist is adding an outlier
for(i in 1:nreps){
tryagain<-T
#	if(i %in% c(1:100*nreps/100)) print(i)
while(tryagain){ #to ENSURE that we get a good mix of p-value ranges
#get t close to what we want
t<-qnorm(pbreaks[pbins[i]],mean=0,sd=1,lower.tail=F)
if(abs(t)>5)t<-0 #guards against when the bin is 1, and quantile has infinite size
n<-nes[i]
x<-rnorm(n)
e<-rnorm(n)
bhat<-t*sd(e)/(sqrt(n)*sd(x))
if(pbins[i]>=5 & sample(c(2,2,1),1)==2) bhat<-0 #sometimes generate it actually from a null
y<-x*bhat*sample(c(-1,1),1)+e
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
xes[i,1:n]<-x
yes[i,1:n]<-y
pi<-pvals[i]
bini<-min(which(pi<pbreaks))
if(bini==pbins[i]) tryagain<-F
}
#plot(x,y,main=n)
#readline(prompt='go')
}
################################################
#Fix those that now get an extra outlier
#add it one sd above the max x and max y, or w/e is appropriate for the upper corner that works
#if it's not sig, add the outlier close to above the mean.
for(i in which(pres=='outlier')){
tryAgain<-TRUE
while(tryAgain){
n<-nes[i]
sig.i<-pvals[i]<.05
#grab the middle point from x and y
mx<-rep(mean(x),n)
my<-rep(mean(y),n)
x<-xes[i,1:n]
y<-yes[i,1:n]
distvec<-sqrt((mx-x)^2+(my-y)^2)
switch<-which(distvec==min(distvec))
#NOTE IT PREV VERSIONS THIS NICE DEALY LET US RANDOMLY PUT THE OUTLIER IN W/E CORNER WE WANTED
#Put it in an UPPER CORNER
if(tvals[i]<1 & sig.i) { #slope going down
x[switch]<-min(x)-sd(x)
y[switch]<-max(y)+sd(y)
}
if(tvals[i]>1 & sig.i) {
x[switch]<-max(x)+sd(x)
y[switch]<-max(y)+sd(y)
}
if(!sig.i){
#leave X where it is now
y[switch]<-max(y)+sd(y)*sqrt(2)
}
tvals[i]<-summary(lm(y~x))$coeff[2,3]
pvals[i]<-summary(lm(y~x))$coeff[2,4]
if(sig.i&pvals[i]<.04) tryAgain=FALSE
if(!sig.i&pvals[i]>.06) tryAgain=FALSE
}
xes[i,1:n]<-x
yes[i,1:n]<-y
}
#save(list=c('xes','yes','nreps','pbins','pvals','tvals','nes','pres'),file='data_for_1plots_coursera2.RData')
#load('data_for_1plots_coursera2.RData')
pvals
nes
summary(lm(yes[1,])~xes[1,])
summary(lm(yes[1,]~xes[1,]))
pvals
summary(lm(yes[1,]~xes[2,]))$coef[2,4]
summary(lm(yes[1,]~xes[2,]))$coef
summary(lm(yes[1,]~xes[1,]))$coef[2,4]
for(i in 1:nreps) print(summary(lm(yes[1,]~xes[1,]))$coef[2,4])
for(i in 1:nreps) print(summary(lm(yes[i,]~xes[i,]))$coef[2,4])
pvals
for(i in 1:nreps) {print(i);print(summary(lm(yes[i,]~xes[i,]))$coef[2,4])}
pvals
plot(xes[1,],yes[1,])
